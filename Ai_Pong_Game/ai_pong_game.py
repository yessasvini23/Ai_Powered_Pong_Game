# -*- coding: utf-8 -*-
"""AI_Pong_Game.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1fWHufiOjINcNKRmmKDukiJWbuOBA46rG
"""

import pygame
import random
import numpy as np

# Window size
WIDTH, HEIGHT = 600, 400
BALL_RADIUS = 10
PADDLE_WIDTH, PADDLE_HEIGHT = 10, 60
PADDLE_SPEED = 5
WHITE = (255, 255, 255)
BLACK = (0, 0, 0)
DIFFICULTY = {"easy": 0.2, "medium": 0.5, "hard": 0.9}
WINNING_SCORE = 5

pygame.init()
screen = pygame.display.set_mode((WIDTH, HEIGHT))
clock = pygame.time.Clock()
font = pygame.font.Font(None, 36)

class Paddle:
    def __init__(self, x):
        self.x = x
        self.y = HEIGHT // 2 - PADDLE_HEIGHT // 2
        self.speed = 0

    def move(self):
        self.y += self.speed
        self.y = max(0, min(HEIGHT - PADDLE_HEIGHT, self.y))

    def draw(self):
        pygame.draw.rect(screen, WHITE, (self.x, self.y, PADDLE_WIDTH, PADDLE_HEIGHT))

class Ball:
    def __init__(self):
        self.reset()

    def reset(self):
        self.x, self.y = WIDTH // 2, HEIGHT // 2
        self.vx = random.choice([-3, 3])
        self.vy = random.choice([-3, 3])

    def move(self):
        self.x += self.vx
        self.y += self.vy
        if self.y <= 0 or self.y >= HEIGHT - BALL_RADIUS:
            self.vy *= -1

    def draw(self):
        pygame.draw.circle(screen, WHITE, (self.x, self.y), BALL_RADIUS)

class AI:
    def __init__(self, difficulty):
        self.q_table = {}
        self.learning_rate = 0.1
        self.discount_factor = 0.9
        self.epsilon = 0.1
        self.difficulty = DIFFICULTY[difficulty]

    def get_state(self, ball, paddle):
        return (ball.x, ball.y, ball.vx, ball.vy, paddle.y)

    def choose_action(self, state):
        if np.random.rand() < self.epsilon:
            return random.choice([-PADDLE_SPEED, 0, PADDLE_SPEED])
        return max([-PADDLE_SPEED, 0, PADDLE_SPEED], key=lambda action: self.q_table.get((state, action), 0))

    def update_q_table(self, state, action, reward, next_state):
        current_q = self.q_table.get((state, action), 0)
        max_future_q = max([self.q_table.get((next_state, a), 0) for a in [-PADDLE_SPEED, 0, PADDLE_SPEED]])
        self.q_table[(state, action)] = current_q + self.learning_rate * (reward + self.discount_factor * max_future_q - current_q)

def game_loop(difficulty, human_play=False):
    left_paddle = Paddle(10)
    right_paddle = Paddle(WIDTH - 20)
    ball = Ball()
    left_ai = AI(difficulty)
    right_ai = AI(difficulty)
    left_score, right_score = 0, 0
    running = True

    while running:
        screen.fill(BLACK)
        state_left = left_ai.get_state(ball, left_paddle)
        action_left = left_ai.choose_action(state_left) if not human_play else 0

        keys = pygame.key.get_pressed()
        if human_play:
            if keys[pygame.K_UP]:
                action_left = -PADDLE_SPEED
            elif keys[pygame.K_DOWN]:
                action_left = PADDLE_SPEED

        left_paddle.speed = action_left
        left_paddle.move()

        state_right = right_ai.get_state(ball, right_paddle)
        action_right = right_ai.choose_action(state_right)
        right_paddle.speed = action_right
        right_paddle.move()

        ball.move()

        if ball.x - BALL_RADIUS <= left_paddle.x + PADDLE_WIDTH and left_paddle.y <= ball.y <= left_paddle.y + PADDLE_HEIGHT:
            ball.vx *= -1
            reward = 1
        elif ball.x + BALL_RADIUS >= right_paddle.x and right_paddle.y <= ball.y <= right_paddle.y + PADDLE_HEIGHT:
            ball.vx *= -1
            reward = 1
        else:
            reward = -1 if ball.x < 0 else 0

        if ball.x < 0:
            right_score += 1
            ball.reset()
        elif ball.x > WIDTH:
            left_score += 1
            ball.reset()

        next_state_left = left_ai.get_state(ball, left_paddle)
        left_ai.update_q_table(state_left, action_left, reward, next_state_left)
        next_state_right = right_ai.get_state(ball, right_paddle)
        right_ai.update_q_table(state_right, action_right, reward, next_state_right)

        left_paddle.draw()
        right_paddle.draw()
        ball.draw()

        score_text = font.render(f"{left_score} - {right_score}", True, WHITE)
        screen.blit(score_text, (WIDTH // 2 - 20, 10))

        if left_score >= WINNING_SCORE or right_score >= WINNING_SCORE:
            winner_text = font.render("Game Over! Press R to Restart", True, WHITE)
            screen.blit(winner_text, (WIDTH // 4, HEIGHT // 2))
            pygame.display.flip()
            pygame.time.delay(2000)
            running = False

        pygame.display.flip()
        clock.tick(30)

        for event in pygame.event.get():
            if event.type == pygame.QUIT:
                running = False
            elif event.type == pygame.KEYDOWN and event.key == pygame.K_r:
                game_loop(difficulty, human_play)

    pygame.quit()

if __name__ == "__main__":
    human_vs_ai = True  # Set to False for AI vs AI mode
    game_loop("medium", human_vs_ai)